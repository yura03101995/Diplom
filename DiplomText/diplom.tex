\documentclass[12pt,a4paper]{article}
\usepackage[russian]{babel}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usetikzlibrary{calc,intersections} 
\usepackage{graphics}
\graphicspath{{image/}}
\sloppy

\SetKwInput{KwData}{Исходные параметры}
\SetKwInput{KwResult}{Результат}
\SetKwInput{KwIn}{Входные данные}
\SetKwInput{KwOut}{Выходные данные}
\SetKwIF{If}{ElseIf}{Else}{если}{тогда}{иначе если}{иначе}{конец условия}
\SetKwFor{While}{до тех пор, пока}{выполнять}{конец цикла}
\SetKw{KwTo}{от}
\SetKw{KwRet}{возвратить}
\SetKw{Return}{возвратить}
\SetKwBlock{Begin}{начало блока}{конец блока}
\SetKwSwitch{Switch}{Case}{Other}{Проверить значение}{и выполнить}{вариант}{в противном случае}{конец варианта}{конец проверки значений}
\SetKwFor{For}{цикл}{выполнять}{конец цикла}
\SetKwFor{ForEach}{для каждого}{выполнять}{конец цикла}
\SetKwRepeat{Repeat}{повторять}{до тех пор, пока}
\SetKwProg{Fn}{Function}{}{}
\SetAlgorithmName{Алгоритм}{алгоритм}{Список алгоритмов}


\theoremstyle{definition}
\newtheorem{mydef}{Определение}[section]


\begin{document}
\pagestyle{empty}
\begin{figure}[h!]
  \centering
   \includegraphics[width=0.4\linewidth]{msu2.jpg}
 \end{figure}
 
\centerline {\scriptsize{МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИМЕНИ М. В. ЛОМОНОСОВА}}
\centerline {\scriptsize{ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ И КИБЕРНЕТИКИ}}
\centerline {\scriptsize{КАФЕДРА МАТЕМАТИЧЕСКОЙ КИБЕРНЕТИКИ}}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\bigskip
\bigskip
\bigskip
\centerline{\textbf{Выпускная квалификационная работа}}

\bigskip

\begin{center}
{\large{<<Исследование методов восстановления частично заданных схем из функциональных элементов>>}}
\end{center}

\begin{center}
студента 418 группы
\end{center}
\begin{center}
Трубицына Юрия Алексеевича
\end{center}
\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\begin{flushright}
\textbf{Научный руководитель:}\\
доцент, к. ф. - м. н.\\ 
ШУПЛЕЦОВ МИХАИЛ СЕРГЕЕВИЧ
\end{flushright}
\bigskip

\bigskip

\bigskip
\bigskip

\bigskip\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\centerline{Москва, 2016}

\newpage
\pagestyle{plain}
\tableofcontents


\newpage 

\section{\textbf{Введение}}
\noindent

Основной темой является задача восстановления функциональности для частично заданных СФЭ, которая возникает при попытках скрыть или защитить схему от несанкционированного копирования. В атаках данного типа злоумышленник, получив доступ к описанию интегральной схемы или IP блока, производит его несанкционированное копирование. В дальнейшем, злоумышленник может внести небольшие изменения в украденное описание, чтобы производить и продавать его в качестве своего собственного.\par
Рассмотрим один из видов атак подобного рода - обратное проектирование. Обратное проектирование интегральной схемы предполагает выполнение некоторых из следующих действий:
\begin{enumerate}
\item определение технологии, по которой была произведена интегральная схема \cite{chipworks};
\item извлечение из готовой интегральной схемы ее описания на уровне логических элементов \cite{torrance};
\item определение функциональности, реализуемой интегральной схемой \cite{darpa};
\end{enumerate}

Существует несколько подходов к защите от атак подобного рода:
\begin{enumerate}
\item схемная обфускация;
\item маскировка интегральных схем (camouflaging);
\item раздельное производство.
\end{enumerate}
\par
В данной работе рассматривается третий способ защиты - раздельное производство.

Раздельное производство интегральных схем – набор методологий производства интегральных схем, отличительной особенностью которых является производство интегральной схемы, когда схема изготовляется на нескольких различных фабриках \cite{jarvis}. В основном, в литературе выделяют два основных подхода к раздельному производству интегральных схем:
\begin{enumerate}
\item раздельное производство различных слоев интегральной схемы \cite{Jv};
\item подходы, основанные на 2.5D и 3D интеграции \cite{imeson}.
\end{enumerate}
Современная интегральная схема состоит из множества слоев, которые последовательно изготовляются на поверхности кремниевой пластины при помощи фотолитографического процесса. При этом нижние слои используются для производства транзисторов, то есть основных логических элементов схемы, а верхние уровни задействованы для расположения слоев металлизации, которые используются для соединения логических элементов интегральной схемы. На современном уровне технологий типичная интегральная схема может содержать от 10 до 12 слоев металлизации. При этом минимальное расстояние между проводниками и их линейные размеры на разных слоях отличается. В связи с технологическими ограничениями на верхних слоях расстояние между проводниками и их ширина и высота больше, чем на нижних слоях.
При раздельном производстве производство интегральной микросхемы разделяется на два этапа, которые могут быть выполнены на разных фабриках. На первом этапе на кремниевой пластине создаются транзисторы и создаются нижние слои металлизации (например, до уровня M4 включительно). На втором этапе недостающие слои металлизации наносятся на заготовку, полученную на первом этапе. Выбор уровня металлизации на котором происходит разделение производства является произвольным и зависит от целей и требований заказчика.
Подходы, основанные на 2.5D и 3D интеграции, предполагают интеграцию нескольких кремниевых пластин внутри одного корпуса. При этом пластины располагаются одна над другой и соединяются при помощи специальных прорезов в кремнии, так называемых, TSV (through silicon vias). Чаще всего эти прорезы располагают в узлах регулярной сетки с некоторым фиксированным шагом. 2.5D интеграция предполагает соединение нескольких интегральных схем на специальной коммутирующей пластине, так называемом интерпозере, который состоит только из слоев металлизации, то есть держит только проводники и не содержит логических элементов.
Раздельное производство имеет ряд технологических сложностей. Так, например, после первого этапа требуется транспортировка кремниевых пластин на другую фабрику. Из-за своей хрупкости пластины могут деформироваться и даже трескаться, а также могут возникать повреждения верхнего слоя, что может привести к невозможности нанесения последующих слоев на другой фабрике. Кроме того, в начале второго этапа производства требуется очень аккуратная настройка оборудования и выравнивание кремниевых пластин или отдельных интегральных схем, для обеспечения высокого уровня выхода годных.
Раздельное проектирование существенно затрудняет успешность обратного проектирования, так как злоумышленник, который работает на производстве, может получить только часть интегральной схемы, которая не будет корректно работать, пока она не будет соединена с другой частью, произведенной на другой фабрике.

В данной работе производится попытка моделирования процесса раздельного проектирования. За логическое описание схемы используется представление в виде схемы из функциональных элементов (СФЭ) и следующий метод - удаляются отдельные связи (провода) между функциональными элементами. Таким образом можно получить неполную СФЭ, представляющую часть от полной схемы. 

В данной работе предлагаются алгоритмы и библиотеки, которые способны провести идентификацию класса исходной схемы по замаскированной исходной схеме при помощи алгоритмов машинного обучения. Для идентифицируемого класса взят класс схем, реализующих мультиплексорные функции. Также написан ряд утилит, позволяющих получить реализации мультиплексорных функций в классе СФЭ, на базе которых происходит обучение.

\newpage
\section{\textbf{Основные определения}}

Введем ряд основных определений необходимых для формальной постановки задачи идентификации классов исходной схемы по замаскированной исходной схеме.

\begin{mydef}
${\mathbb{B}}^n = \left\{ {\tilde{\alpha}}^n = \left( \alpha_1, ..., {\alpha}_n\right)\mid {\alpha}_i \in \left\{ 0, 1\right\} \forall i = \overline{1,n}\right\}$.
\end{mydef}

\begin{mydef}
\emph{Булевой функцией} от переменных $x_1, ..., x_n$ будем называть отображение $f: {\mathbb{B}}^n \to {\mathbb{B}}^1$.
\end{mydef}

\begin{mydef}
Схемой из функциональных элементов (СФЭ) будем называть ориентированный помеченный ациклический граф, обладающий следующими свойствами:
\begin{enumerate}
\item в нем существует непустое множество вершин, помеченных как входные вершины;
\item в нем существует непустое множество вершин, помеченных как выходные вершины;
\item множества входных и выходных вершин не пересекаются;
\item вершины, не входящие в множество входных вершин, помечены символом некоторой БФ.
\end{enumerate}
\end{mydef}

Каждая метка вершины из множества входных вершин связана с соответствующей булевой переменной.
Пусть теперь символы, которыми могут быть помечены вершины, могут соответствовать только следующим БФ : NOT, AND, OR, XOR, NAND, NOR, XNOR.

\begin{mydef}
Булеву функцию, реализуемую в вершине СФЭ определим по индукции:
\begin{enumerate}
\item если вершина входит во множество входных вершин и помечена как $x_i$, то БФ, реализуемая в этой вершине есть: $f = x_i$;
\item если вершина не является входом и помечена символом некоторой БФ $F(p_1, ..., p_k)$, то в данной вершине реализуется БФ: $f = F(f_{i_1}, ..., f_{i_k})$, где $f_{i_1}, ..., f_{i_k}$ есть функции, реализуемые в вершинах, из которых исходят входящие в данную вершину ребра;
\end{enumerate}
\end{mydef}

\begin{mydef}
Частично заданной СФЭ (замаскированной СФЭ) $\Sigma$ будем называть такую схему $\Sigma^{'}$, которая получается путем удаления одного или нескольких ребер из исходной схемы $\Sigma$. При этом вершины, инцидентные удаленным ребрам помечаются особым образом.
\end{mydef}

\begin{mydef}
Одновыходной СФЭ будем называть такую СФЭ, у которой множество выходных вершин содержит всего одну вершину графа.
\end{mydef}

Далее будем рассматривать только одновыходные схемы, т. е. схемы с единственной выходной вершиной.

\begin{mydef}
Классом БФ будем называть подмножество множества всех БФ, удовлетворяющих некоторому условию.
\end{mydef}

Определим понятие вхождения СФЭ в класс. 

\begin{mydef}
Одновыходная СФЭ $\Sigma$ входит в класс $G \in P_2$ тогда и только тогда, когда в этот класс входит функция, реализуемая на выходе СФЭ.
\end{mydef}


\newpage
\section{\textbf{Постановка задачи}}
\noindent
\begin{enumerate}
\item Выделить набор признаков СФЭ, которые будут использоваться для решения задачи распознавания;
\item Реализовать и протестировать алгоритмы вычисления признаков СФЭ; 
\item Реализовать алгоритм построения случайных СФЭ, реализующих мультиплексоры, с фиксированным значением выделенных признаков;
\item Провести машинное обучение на базе выборки из построенных мультиплексоров;
\item Реализовать алгоритм случайного удаления контакта;
\item Провести контрольную классификацию СФЭ с удаленными контактами. 
\end{enumerate}

\newpage
\section{Основная часть}

\subsection{\textbf{Выделение набора признаков СФЭ, которые будут использоваться для машинного обучения}}
\noindent

Были выделены следующие признаки:
\begin{enumerate}
\item доля каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR};
\item максимальная полустепень исхода/захода вершин;
\item минимальная полустепень исхода/захода вершин;
\item средняя полустепень исхода/захода вершин;
\item средняя глубина, нормированная на максимальную глубину;
\item среднее количество значащих переменных, нормированное на общее количество переменных;
\end{enumerate}

Рассчитывать первые три пункта достаточно просто: доля возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR} это есть число вершин, помеченных этим функциональным элементом деленное на общее число вершин; максимальная/минимальная полустепень исхода/захода вершин - очевидно. Приведем рассчетные формулы для остальных пунктов. Введем ряд обозначений:
\begin{enumerate}
\item $d^{+}\left(v\right)$ - полустепень захода вершины $v$, равна количеству входных ребер;
\item $d^{-}\left(v\right)$ - полустепень исхода вершины $v$, равна количеству выходных ребер;
\item $I$ - множество всех входных вершин СФЭ;
\item $O$ - множество всех выходных вершин СФЭ;
\item $V$ - множество всех вершин СФЭ;
\item $D\left(v\right)$ - глубина вершины $v$;
\item $D\left(\Sigma\right)$ - глубина СФЭ $\Sigma$;
\item $CS\left(v\right)$ - существенные переменные вершины $v$;
\end{enumerate}\par
Расчет средней полустепени захода: $\frac{\sum\limits_{v \in V} d^{+}\left(v\right)}{|V|}$. Исхода аналогично.\par
Расчет средней глубины, нормированной на максимальную глубину: $\frac{\sum\limits_{v \in V} D\left(v\right)}{D\left(\Sigma\right)}$.\par
Вычисление среднего количества значащих переменных, нормированного на общее количество переменных: $\frac{\sum\limits_{v \in V \diagdown I} CS\left(v\right)}{|I|}$.

\newpage

\subsection{\textbf{Реализация способа представления СФЭ на ЭВМ}}
\noindent
Для вычисления выбранных характеристик СФЭ был реализован следующий набор классов: класс Vertex и унаследованный от него класс Gate. Vertex предназначен для хранения входных вершин. Gate хранит данные о вершинах, не являющихся входными. Vertex - имеет поля имени, выходной степени и глубины. Унаследованный от него Gate ещё имеет поле для хранения входных ребер и типа(OR,XOR и т. д.).

Реализован синтаксический анализатор СФЭ, заданных при помощи языка Verilog. Анализатор представлен в виде класса Parser, в котором реализован метод, возвращающий только значащие лексемы.

СФЭ реализована на ЭВМ как отдельный класс SFE с контейнером указателей на входные вершины(inputs), контейнером указателей на выходные вершины(ouputs) и контейнером указателей на вершины, которые не являются ни входными, ни выходными(gates). Схема задается в файле на языке Verilog. Также реализован ряд методов для работы с данным классом.

\newpage

\subsection{\textbf{Реализация алгоритмов вычисления признаков схемы}}
\noindent

В классе SFE реализованы следующие методы для рассчетов признаков СФЭ:
\begin{enumerate}
\item SFE::getPercentageTypeGate(typeGate t) - процент каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR}, который подается на вход методу;
\item SFE::getMaxInputDegree() / SFE::getMaxOutputDegree() - максимальная полустепень исхода/захода вершин - проходим по всем вершинам, считаем полустепень исхода/захода, храним максимальную;
\item SFE::getMinInputDegree() / SFE::getMinOutputDegree() - минимальная полустепень исхода/захода вершин - проходим по всем вершинам, считаем полустепень исхода/захода, храним минимальную;
\item SFE::getMiddleInputDegree() / SFE::getMiddleInputDegree() - средняя полустепень исхода/захода вершин - проходим по всем вершинам, считаем сумму полустепеней исхода/захода, делим на количество вершин, умноженное на максимальную полустепень исхода/захода;
\item SFE::getPercentageMiddleDepth() - средняя глубина, нормированная на максимальную глубину - проходим по всем вершинам, считаем сумму глубин, делим на количество вершин, умноженное на глубину СФЭ;
\item SFE::getPercentageMiddleSignVar() - среднее количество существенных переменных, нормированное на общее количество переменных - проходим по всем вершинам, считаем сумму количества существенных переменных для каждой вершины, делим на количество вершин, умноженное на количество переменных.
\end{enumerate}\par

\newpage

\subsection{\textbf{Реализация алгоритма построения случайных СФЭ}}
\noindent
Для тестирования полученных алгоритмов, а также для генерации обучающих выборок СФЭ для машинного обучения, был реализован отдельный алгоритм, генерирующий случайную СФЭ, представленную в виде файла-описания на Verilog и реализующую мультиплексор. \par




\newpage
\section{Полученные результаты}\par
Разработана реализация на языке С++ СФЭ на ЭВМ с возможность вычисления описанных выше признаков и считывания описания с файла-описания. Разработан генератор случайных СФЭ, реализующих мультиплексоры. Написан ряд утилит, для работы с Verilog-представлением схем. Весь исходный код доступен по ссылке:
\centerline{https://github.com/yura03101995/Diplom}


\newpage


\begin{thebibliography}{30}

\bibitem{chipworks} Chipworks: 
\emph{"Intel‘s 22-nm Tri-gate Transistors Exposed"}, http://www.chipworks.com/blog/technologyblog/2012/04/23/intels-22-nm-tri-gate-transistors-exposed/, 2012

\bibitem{torrance} R. Torrance and D. James: 
\emph{"The state-of-the-art in semiconductor reverse engineering"}, IEEE/ACM Design Automation Conference, pp. 333–338, 2011

\bibitem{darpa} DARPA: 
\emph{"Integrity and Reliability of Integrated Circuits (IRIS)"}, http://www.darpa.mil/Our{\_}Work/MTO/Programs/
Integrity{\_}and{\_}Reliability{\_}of{\_}Integrated{\_}Circuits{\_}(IRIS).aspx, 2012

\bibitem{Jv} Jeyavijayan (Jv) Rajendran, Ozgur Sinanoglu, and Ramesh Karri: 
\emph{"Is split manufacturing secure?. In Proceedings of the Conference on Design, Automation and Test in Europe (DATE '13)"}, EDA Consortium, San Jose, CA, USA, 1259-1264, 2013

\bibitem{imeson} Frank Imeson, Ariq Emtenan, Siddharth Garg, and Mahesh V. Tripunitara:
\emph{"Securing computer hardware using 3D integrated circuit (IC) technology and split manufacturing for obfuscation. In Proceedings of the 22nd USENIX conference on Security (SEC'13)."}, USENIX Association, Berkeley, CA, USA, 495-510, 2013

\bibitem{jarvis} R.W Jarvis and M. G. McIntyre: 
\emph{"Split manufacturing method for advanced semiconductor circuits."}, US Patent no. 7195931, 2004


\end{thebibliography}


\end{document}

