\documentclass[12pt,a4paper]{article}
\usepackage[russian]{babel}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usetikzlibrary{calc,intersections} 
\usepackage{graphics}
\usepackage{multirow}

\graphicspath{{image/}}
\sloppy

\SetKwInput{KwData}{Исходные параметры}
\SetKwInput{KwResult}{Результат}
\SetKwInput{KwIn}{Входные данные}
\SetKwInput{KwOut}{Выходные данные}
\SetKwIF{If}{ElseIf}{Else}{если}{тогда}{иначе если}{иначе}{конец условия}
\SetKwFor{While}{до тех пор, пока}{выполнять}{конец цикла}
\SetKw{KwTo}{от}
\SetKw{KwRet}{возвратить}
\SetKw{Return}{возвратить}
\SetKwBlock{Begin}{начало блока}{конец блока}
\SetKwSwitch{Switch}{Case}{Other}{Проверить значение}{и выполнить}{вариант}{в противном случае}{конец варианта}{конец проверки значений}
\SetKwFor{For}{цикл}{выполнять}{конец цикла}
\SetKwFor{ForEach}{для каждого}{выполнять}{конец цикла}
\SetKwRepeat{Repeat}{повторять}{до тех пор, пока}
\SetKwProg{Fn}{Function}{}{}
\SetAlgorithmName{Алгоритм}{алгоритм}{Список алгоритмов}


\theoremstyle{definition}
\newtheorem{mydef}{Определение}[section]


\begin{document}
\begin{titlepage}

\newpage
 
% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
\begin{center}
\begin{figure}[h]
\center
\includegraphics[scale=0.4]{msu2.jpg}
\end{figure}
\footnotesize {Московский государственный университет} 
\footnotesize {имени М. В. Ломоносова} 
\linebreak
\normalsize {Факультет вычислительной математики и кибернетики} 
\linebreak
\normalsize {Кафедра математической кибернетики}
\linebreak
\linebreak
\linebreak
\large{\text {Трубицын Юрий Алексеевич}}
\linebreak
\linebreak
\large{\textbf{Исследование методов восстановления частично заданных схем из функциональных элементов}}
\linebreak
\linebreak
\large{\text {ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА}}
\linebreak
\linebreak
\end{center}

 
\begin{flushright}
\Large {\bf Научный руководитель:}\\
\Large к.ф.- м.н., доцент\\
\Large М. С. Шуплецов\\
\end{flushright}

\vspace{\fill}
\begin{center} 
\large{Москва, 2017}
\end{center}
%\thispagestyle{empty} 

\end{titlepage}

\newpage
\pagestyle{plain}
\tableofcontents


\newpage 

\section{\textbf{Введение}}
\noindent

В данной работе будет рассматриваться модель частично заданных схем из функциональных элементов (СФЭ), в которой каждая схема задана неполным набором ребер, то есть некоторые контакты заранее скрыты. Решая задачу восстановления таких СФЭ может быть оценена защищенность от несанкционированного копирования и других видов подобных несанкционированных действий. \par
%Основной целью данной дипломной работы является написание программы, которая оценивает защищенность схем от несанкционированного копирования. Злоумышленник, получив доступ к описанию интегральной схемы или IP блока, производит его несанкционированное копирование. В дальнейшем, злоумышленник может внести небольшие изменения в украденное описание, чтобы производить и продавать его в качестве своего собственного.\par
Рассмотрим один из видов подобных несанкционированных действий - обратное проектирование. Обратное проектирование интегральной схемы предполагает выполнение некоторых из следующих действий:
\begin{enumerate}
\item определение технологии, по которой была произведена интегральная схема \cite{chipworks};
\item извлечение из готовой интегральной схемы ее описания на уровне логических элементов \cite{torrance};
\item определение функциональности, реализуемой интегральной схемой \cite{darpa};
\end{enumerate}

Существует несколько подходов к защите от атак подобного рода:
\begin{enumerate}
\item схемная обфускация (приведение исходной схемы к виду, сохраняющему её функциональность, но затрудняющему анализ и понимание структуры реализации ее отдельных частей)\cite{rajendran};
\item маскировка интегральных схем (англ. -- camouflaging -- набор методов, изменяющих топологическое описание (layout) интегральной схемы для того, чтобы затруднить работу методов обратного проектирования, которые основаны на алгоритмах распознавания образов, работающих с изображениями слоев, извлеченных из интегральной схемы);
\item раздельное производство(см. ниже).
\end{enumerate}
\par
В данной работе рассматривается третий способ защиты - раздельное производство.

Раздельное производство интегральных схем -- набор методологий производства интегральных схем, отличительной особенностью которых является изготовление интегральной схемы на нескольких различных фабриках \cite{jarvis}. В основном, в литературе выделяют два основных подхода к раздельному производству интегральных схем:
\begin{enumerate}
\item раздельное производство различных слоев интегральной схемы \cite{Jv};
\item подходы, основанные на 2.5D и 3D интеграции(см. ниже) \cite{imeson}.
\end{enumerate}
Современная интегральная схема состоит из множества слоев, которые последовательно изготовляются на поверхности кремниевой пластины при помощи фотолитографического процесса. При этом нижние слои используются для производства транзисторов, то есть основных логических элементов схемы, а верхние уровни задействованы для расположения слоев металлизации, которые используются для соединения логических элементов интегральной схемы. На современном уровне технологий типичная интегральная схема может содержать от 10 до 12 слоев металлизации. При этом минимальное расстояние между проводниками и их линейные размеры на разных слоях отличается. В связи с технологическими ограничениями на верхних слоях расстояние между проводниками и их ширина и высота больше, чем на нижних слоях.
При раздельном производстве изготовление интегральной микросхемы разделяется на два этапа, которые могут быть выполнены на разных фабриках. На первом этапе на кремниевой пластине создаются транзисторы и создаются нижние слои металлизации (например, до четвертого уровня металлизации включительно). На втором этапе недостающие слои металлизации наносятся на заготовку, полученную на первом этапе. Выбор уровня металлизации на котором происходит разделение производства является произвольным и зависит от целей и требований заказчика.
Подходы, основанные на 2.5D и 3D интеграции, предполагают интеграцию нескольких кремниевых пластин внутри одного корпуса. При этом пластины располагаются одна над другой и соединяются при помощи специальных прорезов в кремнии, так называемых, TSV (through silicon vias). Чаще всего эти прорезы располагают в узлах регулярной сетки с некоторым фиксированным шагом. 2.5D интеграция предполагает соединение нескольких интегральных схем на специальной коммутирующей пластине, так называемом интерпозере, который состоит только из слоев металлизации, то есть содержит только проводники и не содержит логических элементов.
Раздельное производство имеет ряд технологических сложностей. Так, например, после первого этапа требуется транспортировка кремниевых пластин на другую фабрику. Из-за своей хрупкости пластины могут деформироваться и даже трескаться, а также могут возникать повреждения верхнего слоя, что может привести к невозможности нанесения последующих слоев на другой фабрике. Кроме того, в начале второго этапа производства требуется очень аккуратная настройка оборудования и выравнивание кремниевых пластин или отдельных интегральных схем, для обеспечения высокого уровня выхода годных.
Раздельное проектирование существенно затрудняет успешность обратного проектирования, так как злоумышленник, который работает на производстве, может получить только часть интегральной схемы, которая не будет корректно работать, пока она не будет соединена с другой частью, произведенной на другой фабрике.

В данной работе производится попытка оценить возможность восстановить функциональность производимого устройства по фрагменту его описания, отправляемого на фабрику в рамках первого этапа производства. Предполагается, что для логического описания интегральной схемы используется представление в виде схемы из функциональных элементов (СФЭ) с удаленными соединениями. При этом считается, что вершины СФЭ, смежные удаленным соединениям, имеют специальные пометки. Таким образом, можно поставить задачу восстановления исходной функциональности по такой частично заданной СФЭ. 

Заметим, что данная задача является некорректно поставленной, так как, в общем случае может существовать несколько корректных восстановлений и не имеет корректной математической постановки, так как не задано распределение на пространстве всевозможных восстановлений, а это значит, что любое восстановление равновероятно. Если же задать данное распределение, то задача становится тривиальную. Поэтому мы не будем требовать знание распределения, но потребуем выборку, состоящую из схем одного класса, произведенных одинаковым образом, а также знание способа сокрытия (в нашем случае -- случайное удаление контактов).

В данной работе предложены и реализованы алгоритмы и библиотеки, которые способны провести идентификацию класса исходной схемы по частично заданной исходной схеме при помощи алгоритмов машинного обучения. Также написан ряд утилит, позволяющих получить реализации мультиплексорных функций в классе СФЭ.

\newpage
\section{\textbf{Основные определения}}

Введем ряд основных определений.

\begin{mydef}
${\mathbb{B}}^n = \left\{ {\tilde{\alpha}}^n = \left( \alpha_1, ..., {\alpha}_n\right)\mid {\alpha}_i \in \left\{ 0, 1\right\} \forall i = \overline{1,n}\right\}$.
\end{mydef}

\begin{mydef}
\emph{Булевой функцией} (БФ) от переменных $x_1, ..., x_n$ будем называть отображение $f: {\mathbb{B}}^n \to {\mathbb{B}}^1$.
\end{mydef}

\begin{mydef}
\emph{Полустепенью исхода (захода) $d^{+}_{G}\left(\upsilon\right)$ } вершины $\upsilon$ ориентированного графа $G$ назовем число ребер исходяших из данной вершины (соответственно, заходящих в данную вершину).
\end{mydef}

Обозначим множество всех булевых функций, зависящих от $n$ переменных, как $P_2^n$.
Обозначим $P_2 = \bigcup_{n=1}^{\infty} P_2^n$.

Пусть у нас задан счетный упорядоченный алфавит входных булевых переменных $\mathcal{X} = \left\{ x_1, x_2, ..., x_n, ... \right\}$ и задан $\mathcal{Z} = \left\{ z_1, ..., z_n, ... \right\}$ - счетный упорядоченный алфавит выходных булевых переменных, который не пересекается с $\mathcal{X}$. Пусть также задано $\mathcal{B} = \left\{ f_1, ..., f_n, ...\right\}$ - счетное упорядоченное множество функциональных символов, каждому из которых соответствует некоторая функция из $P_2$.

\begin{mydef}
\cite{lozhkin}
\emph{Схемой из функциональных элементов над базисом $\mathcal{B}$} называется ориентированная ациклическая упорядоченная сеть $\Sigma$, входная выборка которой состоит из всех истоков $\Sigma$, а вершины помечены следующим образом:
\begin{enumerate}
\item каждому входу (выходу) $\Sigma$ сопоставлена булева переменная из $\mathcal{X}$ (соответственно $\mathcal{Z}$), являющаяся пометкой связанной с ним вершины, причём различным входам (выходам) сопоставлены различные булевы переменные, а упорядоченность вершин во входной и выходной выборках $\Sigma$ определяется упорядоченностью сопоставленных им булевым переменным;
\item каждая отличная от истока вершина $\upsilon$ в схеме $\Sigma$ помечена некоторым
функциональным символом из $\mathcal{B}$, причем количество существенных переменых 
функции, которой соответсвует этот символ, равно полустепени захода данной вершины $d^{+}_{\Sigma}\left(\upsilon\right)$.
\end{enumerate} 
\end{mydef}

%Определим вид базиса, в котором в дальнейшем будем работать. Для этого введем следующие множества:
%\begin{center} 
%$AND2 = \left\{ x_1 \wedge x_2 | x_1, x_2 \in \mathcal{X} \right\}$,\\
%$AND3 = \left\{ x_1 \wedge x_2 \wedge x_3 | x_1, x_2, x_3 \in \mathcal{X} \right\}$,\\
%$AND4 = \left\{ x_1 \wedge x_2 \wedge x_3 \wedge x_4 | x_1, x_2, x_3, x_4 \in \mathcal{X} \right\}$,\\
%$OR2 = \left\{ x_1 \vee x_2 | x_1, x_2 \in \mathcal{X} \right\}$,\\
%$OR3 = \left\{ x_1 \vee x_2 \vee x_3 | x_1, x_2, x_3 \in \mathcal{X} \right\}$,\\
%$OR4 = \left\{ x_1 \vee x_2 \vee x_3 \vee x_4 | x_1, x_2, x_3, x_4 \in \mathcal{X} \right\}$,\\
%$NAND2 = \left\{ \overline{x_1 \wedge x_2} | x_1, x_2 \in \mathcal{X} \right\}$,\\
%$NAND3 = \left\{ \overline{x_1 \wedge x_2 \wedge x_3} | x_1, x_2, x_3 \in \mathcal{X} \right\}$,\\
%$NAND4 = \left\{ \overline{x_1 \wedge x_2 \wedge x_3 \wedge x_4} | x_1, x_2, x_3, x_4 \in \mathcal{X} \right\}$,\\
%$NOR2 = \left\{ \overline{x_1 \vee x_2} | x_1, x_2 \in \mathcal{X} \right\}$,\\
%$NOR3 = \left\{ \overline{x_1 \vee x_2 \vee x_3} | x_1, x_2, x_3 \in \mathcal{X} \right\}$,\\
%$NOR4 = \left\{ \overline{x_1 \vee x_2 \vee x_3 \wedge x_4} | x_1, x_2, x_3, x_4 \in \mathcal{X} \right\}$,\\
%$NOT = \left\{ \overline{x} | x \in \mathcal{X} \right\}$,\\
%$AND = AND2 \cup AND3 \cup AND4$,\\
%$OR = OR2 \cup OR3 \cup OR4$,\\
%$XOR = \left\{ x_1 \bigoplus x_2 | x_1, x_2 \in \mathcal{X} \right\}$,\\
%$XNOR = \left\{ \overline{x_1 \bigoplus x_2} | x_1, x_2 \in \mathcal{X} \right\}$,\\
%$NAND = NAND2 \cup NAND3 \cup NAND4$,\\
%$NOR = NOR2 \cup NOR3 \cup NOR4$
%\end{center}

%Таким образом, базис будет представлен следующим множеством:
%\begin{equation}
%B = NOT \cup AND \cup OR \cup XOR \cup XNOR \cup NAND \cup NOR.
%\end{equation}
В дальнейшем будем использовать базис $B$ из всех ФАЛ существенно зависящих не более, чем от двух переменных.

\begin{mydef}
Булеву функцию, реализуемую в вершине СФЭ определим по индукции:
\begin{itemize}
\item \textbf{Базис индукции:} если вершина входит во множество входных вершин и помечена как $x_i$, то БФ, реализуемая в этой вершине есть: $f = x_i$;
\item \textbf{Шаг индукции:} если вершина не является входом и помечена символом некоторой БФ $F(p_1, ..., p_k)$, то в данной вершине реализуется БФ: $f = F(f_{i_1}, ..., f_{i_k})$, где $f_{i_1}, ..., f_{i_k}$ есть функции, реализуемые в вершинах, из которых исходят входящие в данную вершину ребра.
\end{itemize}
\end{mydef}

Введем также $X^{\ast} = \left\{ x^{\ast}_1, \dots, x^{\ast}_n, \dots \right\}$ -- счетный упорядоченный алфавит заходов удаленных контактов,
$Z^{\ast} = \left\{ z^{\ast}_1, \dots, z^{\ast}_n, \dots \right\}$ -- счетный упорядоченный алфавит исходов удаленных контактов.

\begin{mydef}
Частично заданной СФЭ (замаскированной СФЭ) $\Sigma$ будем называть такую схему $\Sigma^{'}$, которая получается путем удаления одного или нескольких ребер из исходной схемы $\Sigma$. При этом вершины, инцидентные удаленным ребрам помечаются некоторой переменной из множеств $X^{\ast}$ и $Z^{\ast}$ в зависимости от того, было ли ребро заходящим или исходящим.
\end{mydef}

%\begin{mydef}
%Одновыходной СФЭ будем называть такую СФЭ, у которой множество выходных вершин содержит всего одну вершину графа.
%\end{mydef}

Далее будем рассматривать только одновыходные схемы, т. е. схемы с единственной выходной вершиной.

Введем понятие регрессионной модели.

\begin{mydef}
Регрессионная модель $f(\mathbf{w},\mathbf{x})$ -- это параметрическое семейство функций, задающее отображение
\begin{equation}
f: W \times X \longrightarrow Y,
\end{equation}
где $\mathbf{w} \in W$ -- пространтсво параметров, $\mathbf{x} \in X$ -- пространство свободных переменных, Y -- пространство зависимых переменных.
Так как регрессионный анализ предполагает поиск зависимости матожидания случайной величины от свободных переменных $E(y|\mathbf{x})=f(\mathbf{x})$, то в ее состав входит аддитивная случайная величина $\varepsilon$:
\begin{equation}
y=f(\mathbf{w},\mathbf{x})+\varepsilon.
\end{equation}
Модель является настроенной (обученной) когда зафиксированы ее параметры, то есть модель задаёт отображение
\begin{equation}
f:X \longrightarrow Y
\end{equation}
для фиксированного значения $\bar{\mathbf{w}}$.
\end{mydef}

Регрессионная модель в данной работе играет роль решающего правила, согласно которому будет приниматься решение, является ли схема объектом заданного класса или же нет. 

В общем виде восстановить функциональность частично заданной СФЭ невозможно, так как мы не знаем распределния на пространстве всевозможных восстановлений. Поэтому мы априорно предполагаем, что для сокрытия использовался определенный алгоритм и возникает задача классификации.\par
Таким образом, формальная постановка задачи звучит так: реализовать алгоритмы, на вход которых подается частично заданная СФЭ. Выходом алгоритма должно быть решение о принадлежности объекта заданному классу.\par
Для тестирования алгоритма в качестве идентифицируемого класса взят класс схем, реализующих мультиплексорные функции.


\newpage
\section{\textbf{Постановка задачи}}
\noindent
\begin{enumerate}
\item Выделить набор признаков СФЭ, которые будут использоваться для решения задачи распознавания, а также реализовать и протестировать алгоритмы вычисления признаков СФЭ;
\item Построить регрессионную модель;
\item Протестировать построенную модель на примере класса мультиплексорных функций. 
\end{enumerate}

\newpage
\section{Основная часть}

\subsection{\textbf{Выделение набора признаков СФЭ, которые будут использоваться для решения задачи распознавания}}
\noindent

Для того, чтобы провести классификацию СФЭ, необходимо каждую схему отобразить в векторное пространство. Для этого мы выделяем набор численных признаков схемы, которые объединяются в вектор, ставящийся в соответвие заданной схемы.\par
\begin{mydef}
Входная вершина $\upsilon$ является присоединенной входной вершиной к вершине $\omega$ в схеме $\Sigma$, если в схеме $\Sigma$ существует ориентированный путь из $\upsilon$ в $\omega$.
\end{mydef}
Введем ряд обозначений:
\begin{enumerate}
\item $d^{+}_{\scriptsize{\Sigma}}\left(\upsilon\right)$ - полустепень захода вершины $\upsilon$ схемы $\Sigma$, равна количеству входных ребер;
\item $d^{-}_{\scriptsize{\Sigma}}\left(\upsilon\right)$ - полустепень исхода вершины $\upsilon$ схемы $\Sigma$, равна количеству выходных ребер;
\item $I_{\scriptsize{\Sigma}}$ - множество всех входных вершин СФЭ $\Sigma$;
\item $O_{\scriptsize{\Sigma}}$ - множество всех выходных вершин СФЭ $\Sigma$;
\item $\Upsilon_{\scriptsize{\Sigma}}$ - множество всех вершин СФЭ $\Sigma$;
\item $D_{\scriptsize{\Sigma}}\left(\upsilon\right)$ - глубина вершины $\upsilon$ в схеме $\Sigma$;
\item $D\left(\Sigma\right)$ - глубина СФЭ $\Sigma$;
\item $CS_{\scriptsize{\Sigma}}\left(\upsilon\right)$ - присоединенные к $\upsilon$ входные вершины в схеме $\Sigma$.
\end{enumerate}\par
Введем вспомогательные определения:
\begin{mydef}
Средней полустепень захода схемы $\Sigma$ есть следующая величина: 
\begin{equation}
\widetilde{d^{+}}\left(\Sigma\right) = \frac{\sum\limits_{\upsilon \in \Upsilon_{\scriptsize{\Sigma}}} d^{+}\left(\upsilon\right)}{|\Upsilon_{\scriptsize{\Sigma}}|}.
\end{equation} 
\end{mydef}

Средняя полустепень исхода СФЭ $\Sigma$ вводится аналогично.\par

\begin{mydef}
Cредняя глубина, нормированная на максимальную глубину схемы $\Sigma$, есть следующая величина: 
\begin{equation}
\widetilde{D}\left(\Sigma\right) = \frac{\sum\limits_{\upsilon \in \Upsilon_{\scriptsize{\Sigma}}} D\left(\upsilon\right)}{D\left(\Sigma\right)}.
\end{equation}
\end{mydef}

\begin{mydef}
Cреднее количество присоединенных входных вершин, нормированное на общее количество переменных,
есть следующая величина: 
\begin{equation}
\widetilde{CS}\left(\Sigma\right) = \frac{\sum\limits_{\upsilon \in {\Upsilon}_{\scriptsize{\Sigma}} \diagdown I_{\scriptsize{\Sigma}}} |CS_{\scriptsize{\Sigma}}\left(\upsilon\right)|}{|I_{\scriptsize{\Sigma}}|}.
\end{equation}
\end{mydef}
\begin{mydef}
Доля функционального элемента из базиса $B$ --  это есть число вершин, помеченных этим функциональным элементом деленное на общее число вершин.
\end{mydef}

Для численных характеристик были выделены следующие признаки:
\begin{enumerate}
\item доля каждого функционального элемента из базиса $B$;
\item максимальная полустепень исхода вершин, нормированная на количество контактов в СФЭ;
\item максимальная полустепень захода вершин;
\item минимальная полустепень исхода/захода вершин;
\item средняя полустепень исхода/захода вершин;
\item средняя глубина, нормированная на максимальную глубину;
\item среднее количество значащих присоединенных, нормированное на общее количество переменных;
\end{enumerate}

\newpage 

\subsection{\textbf{Реализация алгоритмов вычисления признаков СФЭ}}

Для хранения СФЭ в памяти ЭВМ был реализован следующий набор классов: 
\begin{enumerate}
\item класс Vertex -- моделирует вершину графа, предназначен для хранения входных вершин;
\item класс Gate -- наследуется от Vertex, хранит данные о вершинах, не являющихся входными;
\item класс SFE -- хранит представление СФЭ на ЭВМ, состоит из контейнера указателей на входные вершины(inputs), контейнера указателей на выходные вершины(ouputs) и контейнера указателей на вершины, которые не являются ни входными, ни выходными(gates), а также некоторые вспомогательные поля для оптимизации вычислений.
\end{enumerate}

Для формального описания схем из функиональных элементов используется язык \textit{Verilog} 
\cite{soloview}. 
При описании схем из функиональных элементов на языке \textit{Verilog} используются только элементы 
комбинационной логики \cite{pospelov}.
Реализован синтаксический анализатор языка \textit{Verilog}. Анализатор представлен в виде класса 
ParserVerilog.

Определим несколько понятий, необходимых для описания работы алгоритма.

\begin{mydef}
Инверсно-конъюнктивный граф (от англ. -- And-Inventer Graph -- AIG) - ориентированный граф без петель, который состоит из узлов с двумя входами, представляющих логическую конъюнкцию, терминальных узлов, помеченых именами переменных и ребер, некоторые из которых дополнительно содержат метки, указывающие логическое отрицание (см., напр. рис. \ref{pic1}). 
\end{mydef}
Инверсно-конъюнктивный граф представляет структурную реализацию логической функциональности схемы или сети. 
Это представление логической функции редко структурно эффективно для больших схем, но является эффективным представлением для манипулирования булевыми функциями.

\begin{figure}[h!]
  \centering
   \includegraphics[width=0.4\linewidth]{AIG.png}
   \caption{примеры инверсно-конъюнктивных графов}
   \label{pic1}
 \end{figure}

AIG является специальным видом СФЭ в базисе из конъюнкции и инвертора, которые можно эффективно хранить в компьютере.

Будем называть И-узлом -- произвольную вершину инверсно-конъюнктивного графа.

Инверсно-конъюнктивный граф хранится в памяти в виде хэш-таблицы вершин графа с входящими в нее ребрами.

\begin{mydef}
\emph{Одноуровневый структурно хэшированный инверсно-конъюнктивный граф} - инверсно-конъюнктивный граф, в хэш-таблице которого каждый И-узел с определенной парой входов находится в единственном экземпляре. 
\end{mydef}

Для синтеза комбинационной логики, описанной на языке \textit{Verilog}, используется библиотека \textit{Alanmi-ABC}. \textit{Alanmi-ABC} сочетает в себе масштабируемую логическую оптимизацию, основанную на инверсно-конъюнктивных графах и на построении оптимальной по задержке схемы, а также инновационные алгоритмы последовательного синтеза и верификации.\par

На вход \textit{Alanmi-ABC} подается файл описания схемы на языке \textit{Verilog}, в котором используется только комбинационная логика. Библиотека преобразует это описание в некоторый внутренний формат сети. Далее, с помощью средств библиотеки преобразуем текущую сеть в инверсно-конъюнктивный граф посредством одноуровневого структурного хеширования. Результирующий инверсно-конъюнктивный граф представляет собой логическую сеть, состоящую из двухвходовых логических элементов <<И>> и инверторов, представленных в качестве дополнительных атрибутов на ребрах. Это преобразование необходимо для уменьшения размера сети.\par
Средства \textit{Alanmi-ABC} позволяют получить на выходе схемное описание на языке \textit{Verilog} в нужном базисе, отображая ячейки текущей сети в ячейки нужного базиса, используя при этом библиотеку, в которой описаны элементы базиса в некотором формате. Для описания такой библиотеки в программе используется формат GENLIB \cite{genlib}.\par
На выходе получаем описание схемы на языке \textit{Verilog} с ячейками из нужного базиса. После синтеза файл анализируется и преобразуется в экземпляр класса SFE.

В классе SFE реализованы методы для рассчетов признаков схем. Все методы извлечения признаков имеют линейную сложность относительно количества вершин, так как везде используются вариации метода обхода графа <<в ширину>>. Также написаны методы получения значения на выходах СФЭ при заданных входах.
%\begin{enumerate}
%\item SFE::getPercentageTypeGate(typeGate t) - процент каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR}, который подается на вход методу;
%\item SFE::getMaxInputDegree() / SFE::getMaxOutputDegree() - максимальная полустепень исхода/захода вершин - проходим по всем вершинам, считаем полустепень исхода/захода, храним максимальную;
%\item SFE::getMinInputDegree() / SFE::getMinOutputDegree() - минимальная полустепень исхода/захода вершин - проходим по всем вершинам, считаем полустепень исхода/захода, храним минимальную;
%\item SFE::getMiddleInputDegree() / SFE::getMiddleInputDegree() - средняя полустепень исхода/захода вершин - проходим по всем вершинам, считаем сумму полустепеней исхода/захода, делим на количество вершин, умноженное на максимальную полустепень исхода/захода;
%\item SFE::getPercentageMiddleDepth() - средняя глубина, нормированная на максимальную глубину - проходим по всем вершинам, считаем сумму глубин, делим на количество вершин, умноженное на глубину СФЭ;
%\item SFE::getPercentageMiddleSignVar() - среднее количество существенных переменных, нормированное на общее количество переменных - проходим по всем вершинам, считаем сумму количества существенных переменных для каждой вершины, делим на количество вершин, умноженное на количество переменных.
%\end{enumerate}\par

%\newpage

%\subsection{\textbf{Реализация алгоритма построения случайных СФЭ}}
%\noindent
%Для тестирования полученных алгоритмов, а также для генерации обучающих выборок СФЭ для машинного обучения, был реализован отдельный алгоритм, генерирующий случайную СФЭ, представленную в виде файла-описания на Verilog и реализующую мультиплексор. \par
\newpage
\subsection{\textbf{Построение регрессионной модели}}
\noindent
Пусть у нас множество $X$ представлено пространством всевозможных векторов,  размерность которых равной количеству признаков схем, выделенных для решения задачи распознавания.\par
Множество $Y = \left\{ 0, 1 \right\}$.\par
Если настроенная регрессионная модель возвращает 0, значит вектор признаков, полученный из некоторой СФЭ, не попадает в область, в которой предположительно находятся вектора признаков объектов класса. Следовательно, согласно регрессионной модели, данная схема не входит в класс. В случае, когда регрессионная модель возвращает 1 означает, что вектор признаков, полученный из некоторой СФЭ, попадает в область, в которой предположительно находятся вектора признаков объектов класса.\par
Для построения регрессионной модели использовалась библиотека \textit{sklearn} языка \textit{python}. Данная библиотека позволяет использовать различные алгоритмы машинного обучения.\par 
В данной работе иcпользовались следующие алгоритмы машинного обучения:
\begin{itemize}
\item метод опорных векторов (поиск разделяющей гиперплоскости с максимальным зазором в этом пространстве);
\item метод ближайших соседей (простейший метрический классификатор, основанный на оценивании сходства объектов; классифицируемый объект относится к тому классу, которому принадлежат ближайшие к нему объекты обучающей выборки.);
\item случайный лес (алгоритм машинного обучения, заключающийся в использовании комитета (ансамбля) решающих деревьев);
\item логистическая регрессия (метод построения линейного классификатора, позволяющий оценивать апостериорные вероятности принадлежности объектов классам).
\end{itemize}


\newpage
\subsection{\textbf{Тестирование построенной модели на примере класса мультиплексорных функций}}
Тестирование построенной модели проводилось на классе мультиплексорных функций. 
Обучающая выборка состояла из схем следующего вида:
\begin{itemize}
\item Мультиплексоров;
\item Схем, <<близких>> к мультиплексорам (это мультиплексоры, на некоторые входы которых подаются мультиплексоры порядка 2, 3 или 4);
\item Случайные схемы, не являющиеся мультиплексорами.
\end{itemize}
Размер обучающей выборки равен примерно 600 схемам. Количество немультиплексорных и мультиплексорных схем примерно равное.\par
Для проверки точности полученной модели использовался скользящий контроль.
Скользящий контроль работает следующим образом:
\begin{enumerate}
\item Фиксируется некоторое множество разбиений исходной выборки; 
\item Каждое из разбиений делится на две подвыборки: обучающую и контрольную; 
\item Для каждого разбиения выполняется настройка алгоритма по обучающей подвыборке, затем оценивается его средняя ошибка на объектах контрольной подвыборки; 
\item Оценкой скользящего контроля называется средняя по всем разбиениям величина ошибки на контрольных подвыборках.
\end{enumerate}
На рис. \ref{picCV} показаны результаты скользящего контроля.\par
\begin{figure}[h!]
   \centering
   \includegraphics[width=0.6\linewidth]{cross_validation.png}
   \caption{\small{1 - случайный лес, 2 - метод ближайших соседей, 3 - логистическая регрессия, 4 - метод опорных векторов.}}
   \label{picCV}
\end{figure}
По результатам скользящего контроля можно заметить, что лучше всего себя показывают алгоритмы случайного леса и логистичекой регрессии. На них и проходило обучение контрольных выборок.\par
Контрольные выборки состояли из мультиплексорных схем, с некоторой долей удаленных проводов (от 5\% до 75\%). Также есть выборка состоящая из немультиплекорных схем. В нее входят как случайным образом сгенерированные немультиплексорные схемы, так и схемы, <<близкие>> к мультиплексорным. Результаты классификации на контрольных выборках можно увидеть в таблице \ref{tabres}. 

\begin{table}[h!]
\begin{tabular}[t]{|p{8em}|p{8em}|p{8em}|p{8em}|}
\hline 
	{Класс} & { Процент } & { Случайный лес } & { Логистическая }\\
	{} & { удаленных } & { } & { регрессия }\\
	{} & { проводов } & { } & {}\\ 
\hline
\hline
\hline
	\multirow{15}{*}{Мультиплексоры} 
		& {5\%}  & {0.997996} & {1.0}\\ \cline{2-4}
		& {10\%} & {0.997996} & {1.0}\\ \cline{2-4}
		& {15\%} & {0.997996} & {1.0}\\ \cline{2-4}
		& {20\%} & {0.998024} & {1.0}\\ \cline{2-4}
		& {25\%} & {0.997996} & {1.0}\\ \cline{2-4}
		& {30\%} & {0.998004} & {1.0}\\ \cline{2-4}
		& {35\%} & {0.998008} & {1.0}\\ \cline{2-4}
		& {40\%} & {0.998016} & {1.0}\\ \cline{2-4}
		& {45\%} & {0.998028} & {1.0}\\ \cline{2-4}
		& {50\%} & {0.998043} & {1.0}\\ \cline{2-4}
		& {55\%} & {0.998047} & {1.0}\\ \cline{2-4}
		& {60\%} & {0.998047} & {0.998054}\\ \cline{2-4}
		& {65\%} & {0.998058} & {0.997665}\\ \cline{2-4}
		& {70\%} & {0.998058} & {0.997005}\\ \cline{2-4}
		& {75\%} & {0.998095} & {0.996076}\\
\hline
\hline
	{Не мультиплексоры} & { - } & {0.994616} & {0.913862}\\ \cline{1-4}
\hline
\end{tabular}
\caption{Результаты на контрольных выборках}
\label{tabres}
\end{table}

Как можно видеть из результатов, алгоритм логистичекой регрессии дает лучшие результаты на мультиплексорах. Но сильно хуже на немультиплексорных функциях. Из этого можно сделать вывод, что случайный лес лучше подходит для классификации мультиплексорных схем.

\newpage

\section{Полученные результаты}\par
Разработана реализация на языке С++ СФЭ на ЭВМ с возможностью вычисления описанных выше признаков и считывания описания из файла-описания. Разработан генератор случайных СФЭ, реализующих мультиплексоры. Реализован генератор случайных схем, не являющихся мультиплексорами. Разработан алгоритм удаления контактов. Написан ряд утилит, для работы с Verilog-представлением схем. Весь исходный код доступен по ссылке:
\begin{center}
\hyperref[https://github.com/yura03101995/Diplom]{https://github.com/yura03101995/Diplom}
\end{center}


\newpage


\begin{thebibliography}{30}

\bibitem{chipworks} Chipworks: 
\emph{"Intel's 22-nm Tri-gate Transistors Exposed"}, http://www.chipworks.com/blog/technologyblog/2012/04/23/intels-22-nm-tri-gate-transistors-exposed/, 2012

\bibitem{torrance} R. Torrance and D. James: 
\emph{"The state-of-the-art in semiconductor reverse engineering"}, IEEE/ACM Design Automation Conference, pp. 333–338, 2011

\bibitem{darpa} DARPA: 
\emph{"Integrity and Reliability of Integrated Circuits (IRIS)"}, http://www.darpa.mil/Our{\_}Work/MTO/Programs/
Integrity{\_}and{\_}Reliability{\_}of{\_}Integrated{\_}Circuits{\_}(IRIS).aspx, 2012

\bibitem{Jv} Jeyavijayan (Jv) Rajendran, Ozgur Sinanoglu, and Ramesh Karri: 
\emph{"Is split manufacturing secure?. In Proceedings of the Conference on Design, Automation and Test in Europe (DATE '13)"}, EDA Consortium, San Jose, CA, USA, 1259-1264, 2013

\bibitem{imeson} Frank Imeson, Ariq Emtenan, Siddharth Garg, and Mahesh V. Tripunitara:
\emph{"Securing computer hardware using 3D integrated circuit (IC) technology and split manufacturing for obfuscation. In Proceedings of the 22nd USENIX conference on Security (SEC'13)."}, USENIX Association, Berkeley, CA, USA, 495-510, 2013

\bibitem{jarvis} R.W Jarvis and M. G. McIntyre: 
\emph{"Split manufacturing method for advanced semiconductor circuits."}, US Patent no. 7195931, 2004.

\bibitem{rajendran} J. Rajendran, Y. Pino, O. Sinanoglu, and R. Karri:
\emph{"Security analysis of logic obfuscation."}, IEEE/ACM Design Automation Conference, pp. 83--89, 2012.

\bibitem{soloview} Соловьев В. В.:
\emph{"Основы языка проектирования цифровой аппаратуры Verilog."}, М.: Горячая линия -- Телеком, 2014.

\bibitem{pospelov} Поспелов Д. А.:
\emph{"Логические методы анализа и синтеза схем."}, изд. 3-е, перераб. и доп. -- М.: Энергия, 1974.

\bibitem{genlib} Richard Rudell, Cho Moon:
\emph{"GENLIB documentation."}, 1990.

\bibitem{lozhkin} Ложкин С. А.:
\emph{"Лекции по основам кибернетики"}, МГУ им. Ломоносова, ф-т ВМК, 2016.



\end{thebibliography}


\end{document}

