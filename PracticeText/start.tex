\documentclass[12pt,a4paper]{article}
\usepackage{russ}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usetikzlibrary{calc,intersections} 
\usepackage{graphics}
\graphicspath{{image/}}
\sloppy

\SetKwInput{KwData}{Исходные параметры}
\SetKwInput{KwResult}{Результат}
\SetKwInput{KwIn}{Входные данные}
\SetKwInput{KwOut}{Выходные данные}
\SetKwIF{If}{ElseIf}{Else}{если}{тогда}{иначе если}{иначе}{конец условия}
\SetKwFor{While}{до тех пор, пока}{выполнять}{конец цикла}
\SetKw{KwTo}{от}
\SetKw{KwRet}{возвратить}
\SetKw{Return}{возвратить}
\SetKwBlock{Begin}{начало блока}{конец блока}
\SetKwSwitch{Switch}{Case}{Other}{Проверить значение}{и выполнить}{вариант}{в противном случае}{конец варианта}{конец проверки значений}
\SetKwFor{For}{цикл}{выполнять}{конец цикла}
\SetKwFor{ForEach}{для каждого}{выполнять}{конец цикла}
\SetKwRepeat{Repeat}{повторять}{до тех пор, пока}
\SetKwProg{Fn}{Function}{}{}
\SetAlgorithmName{Алгоритм}{алгоритм}{Список алгоритмов}


\theoremstyle{definition}
\newtheorem{mydef}{Определение}[section]


\begin{document}
\pagestyle{empty}
\begin{figure}[h!]
  \centering
   \includegraphics[width=0.4\linewidth]{msu2.jpg}
 \end{figure}
 
\centerline {\scriptsize{МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИМЕНИ М. В. ЛОМОНОСОВА}}
\centerline {\scriptsize{ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ И КИБЕРНЕТИКИ}}
\centerline {\scriptsize{КАФЕДРА МАТЕМАТИЧЕСКОЙ КИБЕРНЕТИКИ}}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\bigskip
\bigskip
\bigskip
\centerline{\textbf{Отчет по преддипломной практике}}

\bigskip

\begin{center}
{\large{<<Разработка и реализация алгоритма распознавания некоторых свойств схем из функциональных элементов>>}}
\end{center}

\begin{center}
студента 418 группы
\end{center}
\begin{center}
Трубицына Юрия Алексеевича
\end{center}
\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\begin{flushright}
\textbf{Научный руководитель:}\\
ассистент, к. ф. - м. н.\\ 
ШУПЛЕЦОВ МИХАИЛ СЕРГЕЕВИЧ
\end{flushright}
\begin{flushright}
\textbf{Руководитель практики от факультета:}\\
ассистент, к. ф. - м. н.\\ 
ШУПЛЕЦОВ МИХАИЛ СЕРГЕЕВИЧ
\end{flushright}
\bigskip

\bigskip

\bigskip
\bigskip

\bigskip\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\centerline{Москва, 2016}

\newpage
\pagestyle{plain}
\tableofcontents


\newpage 

\section{\textbf{Введение}}
\noindent

Основной тематикой данной работы является проблема несанкционированного копирования IP блоков и интегральных схем. В атаках данного типа злоумышленник, получив доступ к описанию интегральной схемы или IP блока, производит его несанкционированное копирование. В дальнейшем, злоумышленник может внести небольшие изменения в украденное описание, чтобы производить и продавать его в качестве своего собственного.\par
Рассмотрим один из видов атак подобного рода - обратное проектирование. Обратное проектирование интегральной схемы предполагает выполнение некоторых из следующих действий:
\begin{enumerate}
\item определение технологии, по которой была произведена интегральная схема \cite{chipworks};
\item извлечение из готовой интегральной схемы ее описания на уровне логических элементов \cite{torrance};
\item определение функциональности, реализуемой интегральной схемой \cite{darpa};
\end{enumerate}

Существует несколько подходов к защите от атак подобного рода:
\begin{enumerate}
\item схемная обфускация;
\item маскировка интегральных схем (camouflaging);
\item раздельное производство.
\end{enumerate}
\par
В моей преддипломной практике рассматривается второй способ защиты - маскировка интегральных схем.

Маскировка интегральных схем – это набор методов, изменяющих топологическое описание (layout) интегральной схемы для того, чтобы затруднить работу методов обратного проектирования, которые основаны на алгоритмах распознавания образов, работающих с изображениями слоев, извлеченных из интегральной схемы. Так, в случае, когда интегральная схема производится с использованием методологии стандартных ячеек (standart cells), используются преобразования, которые стараются сделать все ячейки похожими друг на друга, что приводит к ошибкам при извлечении информации о логическом описании схемы. Например, пустое пространство(white space) схемы может быть заполнено специальными фильтрующими ячейками \cite{baukus_camouflaging}, могут использоваться программируемые стандартные ячейки \cite{baukus_secureCMOS}, а также фиктивные соединения (проводники) \cite{syphermedia}.

В данной работе используется следующий метод маскировки интегральной схемы - удаляются отдельные связи(провода) между функциональными элементами. Также возможно присутствие фиктивных частей в схеме.

В данной работе предлагаются алгоритмы и библиотеки, которые помогут провести идентификацию классов (монотонные, линейные, самодвойственные и т. д.) исходной схемы по замаскированной исходной схеме при помощи алгоритмов машинного обучения.

\newpage
\section{\textbf{Основные определения}}

Введем ряд основных определений необходимых для формальной постановки задачи идентификации классов исходной схемы по замаскированной исходной схеме.

\begin{mydef}
${\mathbb{B}}^n = \left\{ {\tilde{\alpha}}^n = \left( \alpha_1, ..., {\alpha}_n\right)\mid {\alpha}_i \in \left\{ 0, 1\right\} \forall i = \overline{1,n}\right\}$.
\end{mydef}

\begin{mydef}
\emph{Булевой функцией} от переменных $x_1, ..., x_n$ будем называть отображение $f: {\mathbb{B}}^n \to {\mathbb{B}}^1$.
\end{mydef}

\begin{mydef}
Схемой из функциональных элементов (СФЭ) будем называть ориентированный помеченный граф, обладающий следующими свойствами:
\begin{enumerate}
\item в нем существует непустое множество вершин, помеченных как входные вершины;
\item в нем существует непустое множество вершин, помеченных как выходные вершины;
\item множества входных и выходных вершин не пересекаются;
\item вершины, не входящие в множество входных вершин, помечены символом некоторой БФ.
\end{enumerate}
\end{mydef}

Каждая метка вершины из множества входных вершин имеет смысл булевой переменной.
Пусть теперь символы, которыми могут быть помечены вершины, могут соответствовать только следующим БФ : NOT, AND, OR, XOR, NAND, NOR, XNOR.

\begin{mydef}
Булеву функцию, реализуемую в вершине СФЭ определим по индукции:
\begin{enumerate}
\item если вершина входит во множество входных вершин и помечена как $x_i$, то БФ, реализуемая в этой вершине есть: $f = x_i$;
\item если вершина не является входом и помечена символом некоторой БФ $F(p_1, ..., p_k)$, то в данной вершине реализуется БФ: $f = F(f_{i_1}, ..., f_{i_k})$, где $f_{i_1}, ..., f_{i_k}$ есть функции, реализуемые в вершинах, из которых исходят входящие в данную вершину ребра;
\end{enumerate}
\end{mydef}

\begin{mydef}
Частично заданной СФЭ (замаскированной СФЭ) $\Sigma$ будем называть такую схему $\Sigma^{'}$, которая получается путем удаления одного или нескольких ребер из исходной схемы $\Sigma$.
\end{mydef}

\begin{mydef}
Одновыходной СФЭ будем называть такую СФЭ, у которой множество выходных вершин содержит всего одну вершину графа.
\end{mydef}

Далее будем рассматривать только одновыходные схемы, т. е. схемы с единственной выходной вершиной.

\begin{mydef}
Классом БФ будем называть подмножество множества всех БФ, удовлетворяющих некоторому условию.
\end{mydef}

Определим несколько классов.

\begin{mydef}
$T_1 = \cup_{n = 1}^{\infty} \lbrace f\left(x_1, ..., x_n\right) \in P_2^n \vert f(1, ..., 1) = 1 \rbrace$.
\end{mydef}

\begin{mydef}
$T_0 = \cup_{n = 1}^{\infty} \lbrace f\left(x_1, ..., x_n\right) \in P_2^n \vert f(0, ..., 0) = 0 \rbrace$.
\end{mydef}

\begin{mydef}
Пусть $\overline{\alpha} = (\alpha_1, ..., \alpha_n)$ и $\overline{\beta} = (\beta_1, ..., \beta_n)$, тогда:
$\overline{\alpha} \leq (\geq) \overline{\beta} \Leftrightarrow \forall i \in \lbrace 1, ..., n\rbrace: \alpha_i \leq (\geq) \beta_i$.
\end{mydef}

\begin{mydef}
$M = \cup_{n = 1}^{\infty} \lbrace f\left(x_1, ..., x_n\right) \in P_2^n \  \vert \  \forall \overline{\alpha} \leq \overline{\beta}: f\left(\overline{\alpha}\right) \leq f\left(\overline{\beta}\right) \rbrace$.
\end{mydef}

Определим понятие вхождения СФЭ в класс. 

\begin{mydef}
Одновыходная СФЭ $\Sigma$ входит в класс $G \in P_2$ тогда и только тогда, когда в этот класс входит функция, реализуемая на выходе СФЭ.
\end{mydef}

\begin{mydef}
Восстановлением по частично заданной одновыходной СФЭ $\Sigma$ над множеством классов $\Gamma$ будем называть определение вхождения частично заданной одновыходной СФЭ $\Sigma$ в каждый из классов множества $\Gamma$. При этом оценкой качества восстановления над множеством $\Gamma$ будем называть долю классов, таких что исходная одновыходная СФЭ $\Sigma$ входит (не входит), а частично заданная одновыходная СФЭ $\Sigma$ не входит (входит), т. е. количество различий между вхождениями СФЭ.
\end{mydef}

Очевидно, чем ниже оценка, тем лучше восстановление.

\newpage
\section{\textbf{Постановка задачи}}
\noindent
\begin{enumerate}

\item Реализовать и протестировать способ представления СФЭ на ЭВМ;
\item Выделить набор признаков СФЭ, которые будут использоваться для машинного обучения;
\item Реализовать и протестировать алгоритмы вычисления признаков схемы; 
\item Реализовать алгоритм построения случайных СФЭ.
\end{enumerate}

\newpage
\section{Основная часть}

\subsection{\textbf{Реализация и тестирование способа представления СФЭ на ЭВМ}}
\noindent

Имеется класс Vertex и унаследованный от него класс Gate. Vertex предназначен для хранения входных вершин. Gate хранит данные о вершинах, не являющихся входными. Vertex - имеет поля имени, выходной степени и глубины. Унаследованный от него Gate ещё имеет поле для хранения входных ребер и типа(OR,XOR и т. д.).

Реализован класс Parser, который позволяет получать значащие лексемы из файла-описания СФЭ.

СФЭ реализована на ЭВМ как отдельный класс SFE с контейнером указателей на входные вершины(inputs), контейнером указателей на выходные вершины(ouputs) и контейнером указателей на вершины, которые не являются ни входными, ни выходными(gates). Схема задается в файле на языке Verilog. Также реализован ряд методов для работы с данным классом.

Данный набор классов реализован и полность протестирован на разлиных схемах.
\newpage

\subsection{\textbf{Выделение набора признаков СФЭ, которые будут использоваться для машинного обучения}}
\noindent

Были выделены следующие признаки:
\begin{enumerate}
\item процент каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR};
\item максимальная входная/выходная степень;
\item минимальная входная/выходная степень;
\item средняя входная/выходная степень;
\item средняя глубина, нормированная на максимальную глубину;
\item среднее количество значащих переменных, нормированное на общее количество переменных;
\end{enumerate}

Как рассчитывать первые три пункта - очевидно. Приведем рассчетные формулы для остальных пунктов. Введем ряд обозначений:
\begin{enumerate}
\item $d^{+}\left(v\right)$ - входная степень вершины $v$, равна количеству входных ребер;
\item $d^{-}\left(v\right)$ - выходная степень вершины $v$, равна количеству выходных ребер;
\item $I$ - множество всех входных вершин СФЭ;
\item $O$ - множество всех выходных вершин СФЭ;
\item $V$ - множество всех вершин СФЭ;
\item $D\left(v\right)$ - глубина вершины $v$;
\item $D\left(\Sigma\right)$ - глубина СФЭ $\Sigma$;
\item $CS\left(v\right)$ - значащие переменные вершины $v$;
\end{enumerate}\par
Расчет средней входной степени: $\frac{\sum\limits_{v \in V} d^{+}\left(v\right)}{|V|}$. Выходной аналогично.\par
Расчет средней глубины, нормированной на максимальную глубину: $\frac{\sum\limits_{v \in V} D\left(v\right)}{D\left(\Sigma\right)}$.\par
Вычисление среднего количества значащих переменных, нормированного на общее количество переменных: $\frac{\sum\limits_{v \in V \diagdown I} CS\left(v\right)}{|I|}$.

\newpage

\subsection{\textbf{Реализация и тестирование алгоритмов вычисления признаков схемы}}
\noindent

В классе SFE реализованы и протестированы следующие методы для рассчетов признаков СФЭ:
\begin{enumerate}
\item SFE::getPercentageTypeGate(typeGate t) - процент каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR};
\item SFE::getMaxInputDegree() / SFE::getMaxOutputDegree() - максимальная входная/выходная степень;
\item SFE::getMinInputDegree() / SFE::getMinOutputDegree() - минимальная входная/выходная степень;
\item SFE::getMiddleInputDegree() / SFE::getMiddleInputDegree() - средняя входная/выходная степень;
\item SFE::getPercentageMiddleDepth() - средняя глубина, нормированная на максимальную глубину;
\item SFE::getPercentageMiddleSignVar() - среднее количество значащих переменных, нормированное на общее количество переменных.
\end{enumerate}

\newpage

\subsection{\textbf{Реализация алгоритма построения случайных СФЭ}}
\noindent
Для тестирования полученных алгоритмов, а также для генерации обучающих выборок СФЭ для машинного обучения, был реализован отдельный алгоритм, генерирующий случайную СФЭ, представленную в виде файла-описания на Verilog. Алгоритму нужно подать на вход максимальное количество входов, выходов и элементов, не являющихся ни входами, ни выходами, а также имя выходного файла. На основании этих данных алгоритм генерирует случайную СФЭ.

\newpage
\section{Полученные результаты}\par
Разработана реализация на языке С++ СФЭ на ЭВМ с возможность вычисления описанных выше признаков и считывания описания с файла-описания. Разработан генератор случайных СФЭ. 
\newpage
\section{Приложение}
\centerline{https://github.com/yura03101995/PracticeMSU.git}
По данной ссылке можно найти весь исходный код преддипломной практики.
\newpage


\begin{thebibliography}{30}

\bibitem{chipworks} Chipworks: 
\emph{"Intel‘s 22-nm Tri-gate Transistors Exposed"}, http://www.chipworks.com/blog/technologyblog/2012/04/23/intels-22-nm-tri-gate-transistors-exposed/, 2012

\bibitem{torrance} R. Torrance and D. James: 
\emph{"The state-of-the-art in semiconductor reverse engineering"}, IEEE/ACM Design Automation Conference, pp. 333–338, 2011

\bibitem{darpa} DARPA: 
\emph{"Integrity and Reliability of Integrated Circuits (IRIS)"}, http://www.darpa.mil/Our{\_}Work/MTO/Programs/
Integrity{\_}and{\_}Reliability{\_}of{\_}Integrated{\_}Circuits{\_}(IRIS).aspx, 2012

\bibitem{baukus_camouflaging} J. P. Baukus, L. W. Chow, R. P. Cocchi, P. Ouyang, and B. J. Wang:
\emph{"Camouflaging a standard cell based integrated circuit"}, US Patent no. 8151235, 2012

\bibitem{baukus_secureCMOS} J. P. Baukus, L. W. Chow, R. P. Cocchi, P. Ouyang, and B. J. Wang:
\emph{"Building block for a secure CMOS logic cell library"}, US Patent no. 8111089, 2012

\bibitem{syphermedia} SypherMedia:
\emph{"Syphermedia library circuit camouflage technology"}, http://www.smi.tv/solutions.html

\end{thebibliography}


\end{document}

