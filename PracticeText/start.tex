\documentclass[12pt,a4paper]{article}
\usepackage{russ}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usetikzlibrary{calc,intersections} 
\usepackage{graphics}
\graphicspath{{image/}}
\sloppy

\SetKwInput{KwData}{Исходные параметры}
\SetKwInput{KwResult}{Результат}
\SetKwInput{KwIn}{Входные данные}
\SetKwInput{KwOut}{Выходные данные}
\SetKwIF{If}{ElseIf}{Else}{если}{тогда}{иначе если}{иначе}{конец условия}
\SetKwFor{While}{до тех пор, пока}{выполнять}{конец цикла}
\SetKw{KwTo}{от}
\SetKw{KwRet}{возвратить}
\SetKw{Return}{возвратить}
\SetKwBlock{Begin}{начало блока}{конец блока}
\SetKwSwitch{Switch}{Case}{Other}{Проверить значение}{и выполнить}{вариант}{в противном случае}{конец варианта}{конец проверки значений}
\SetKwFor{For}{цикл}{выполнять}{конец цикла}
\SetKwFor{ForEach}{для каждого}{выполнять}{конец цикла}
\SetKwRepeat{Repeat}{повторять}{до тех пор, пока}
\SetKwProg{Fn}{Function}{}{}
\SetAlgorithmName{Алгоритм}{алгоритм}{Список алгоритмов}


\theoremstyle{definition}
\newtheorem{mydef}{Определение}[section]


\begin{document}
\pagestyle{empty}
\begin{figure}[h!]
  \centering
   \includegraphics[width=0.4\linewidth]{msu2.jpg}
 \end{figure}
 
\centerline {\scriptsize{МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ ИМЕНИ М. В. ЛОМОНОСОВА}}
\centerline {\scriptsize{ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ И КИБЕРНЕТИКИ}}
\centerline {\scriptsize{КАФЕДРА МАТЕМАТИЧЕСКОЙ КИБЕРНЕТИКИ}}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\bigskip
\bigskip
\bigskip
\centerline{\textbf{Отчет по преддипломной практике}}

\bigskip

\begin{center}
{\large{<<Разработка и реализация алгоритма распознавания некоторых свойств схем из функциональных элементов>>}}
\end{center}

\begin{center}
студента 418 группы
\end{center}
\begin{center}
Трубицына Юрия Алексеевича
\end{center}
\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\begin{flushright}
\textbf{Научный руководитель:}\\
доцент, к. ф. - м. н.\\ 
ШУПЛЕЦОВ МИХАИЛ СЕРГЕЕВИЧ
\end{flushright}
\begin{flushright}
\textbf{Руководитель практики от факультета:}\\
доцент, к. ф. - м. н.\\ 
ШУПЛЕЦОВ МИХАИЛ СЕРГЕЕВИЧ
\end{flushright}
\bigskip

\bigskip

\bigskip
\bigskip

\bigskip\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\bigskip

\centerline{Москва, 2016}

\newpage
\pagestyle{plain}
\tableofcontents


\newpage 

\section{\textbf{Введение}}
\noindent

Основной темой является задача восстановления функциональности для частично заданных СФЭ, которая возникает при попытках скрыть или защитить схему от несанкционированного копирования. В атаках данного типа злоумышленник, получив доступ к описанию интегральной схемы или IP блока, производит его несанкционированное копирование. В дальнейшем, злоумышленник может внести небольшие изменения в украденное описание, чтобы производить и продавать его в качестве своего собственного.\par
Рассмотрим один из видов атак подобного рода - обратное проектирование. Обратное проектирование интегральной схемы предполагает выполнение некоторых из следующих действий:
\begin{enumerate}
\item определение технологии, по которой была произведена интегральная схема \cite{chipworks};
\item извлечение из готовой интегральной схемы ее описания на уровне логических элементов \cite{torrance};
\item определение функциональности, реализуемой интегральной схемой \cite{darpa};
\end{enumerate}

Существует несколько подходов к защите от атак подобного рода:
\begin{enumerate}
\item схемная обфускация;
\item маскировка интегральных схем (camouflaging);
\item раздельное производство.
\end{enumerate}
\par
В моей преддипломной практике рассматривается третий способ защиты - маскировка интегральных схем.

Раздельное производство интегральных схем – набор методологий производства интегральных схем, отличительной особенностью которых является производство интегральной схемы, когда схема изготовляется на нескольких различных фабриках \cite{jarvis}. В основном, в литературе выделяют два основных подхода к раздельному производству интегральных схем:
\begin{enumerate}
\item раздельное производство различных слоев интегральной схемы \cite{Jv};
\item подходы, основанные на 2.5D и 3D интеграции \cite{imeson}.
\end{enumerate}
Современная интегральная схема состоит множества слоев, которые последовательно изготовляются на поверхности кремниевой пластины при помощи фотолитографического процесса. При этом нижние слои используются для производства транзисторов, то есть основных логических элементов схемы, а верхние уровни задействованы для расположения слоев металлизации, которые используются для соединения логических элементов интегральной схемы. На современном уровне технологий типичная интегральная схема может содержать от 10 до 12 слоев металлизации. При этом минимальное расстояние между проводниками и их линейные размеры на разных слоях отличается. В связи с технологическими ограничениями на верхних слоях расстояние между проводниками и их ширина и высота больше, чем на нижних слоях.
При раздельном производстве производство интегральной микросхемы разделяется на два этапа, которые могут быть выполнены на разных фабриках. На первом этапе на кремниевой пластине создаются транзисторы и создаются нижние слои металлизации (например, до уровня M4 включительно). На втором этапе недостающие слои металлизации наносятся на, полученную на первом этапе, заготовку. Выбор уровня металлизации на котором происходит разделение производства является произвольным и зависит от целей и требований заказчика.
Подходы, основанные на 2.5D и 3D интеграции, предполагают интеграцию нескольких кремниевых пластин внутри одного корпуса. При этом пластины располагаются одна над другой и соединяются при помощи специальных прорезов в кремнии, так называемых, TSV (through silicon vias). Чаще всего эти прорезы располагают в узлах регулярной сетки с некоторым фиксированным шагом. 2.5D интеграция предполагает соединение нескольких интегральных схем на специальной коммутирующей пластине, так называемом интерпозере, который состоит только из слоев металлизации, то есть держит только проводники и не содержит логических элементов.
Раздельное производство имеет ряд технологических сложностей. Так, например, после первого этапа требуется транспортировка кремниевых пластин на другую фабрику. Из-за своей хрупкости пластины могут деформироваться и даже трескаться, а также могут возникать повреждения верхнего слоя, что может привести к невозможности нанесения последующих слоев на другой фабрике. Кроме того, в начале второго этапа производства требуется очень аккуратная настройка оборудования и выравнивание кремниевых пластин или отдельных интегральных схем, для обеспечения высокого уровня выхода годных.
Раздельное проектирование существенно затрудняет успешность обратного проектирования, так как злоумышленник, который работает на производстве, может получить только часть интегральной схемы, которая не будет корректно работать, пока она не будет соединена с другой частью, произведенной на другой фабрике.

В данной работе используется следующий метод - удаляются отдельные связи(провода) между функциональными элементами. Также возможно присутствие фиктивных частей в схеме.

В данной работе предлагаются алгоритмы и библиотеки, которые помогут провести идентификацию классов (монотонные, линейные, самодвойственные и т. д.) исходной схемы по замаскированной исходной схеме при помощи алгоритмов машинного обучения.

\newpage
\section{\textbf{Основные определения}}

Введем ряд основных определений необходимых для формальной постановки задачи идентификации классов исходной схемы по замаскированной исходной схеме.

\begin{mydef}
${\mathbb{B}}^n = \left\{ {\tilde{\alpha}}^n = \left( \alpha_1, ..., {\alpha}_n\right)\mid {\alpha}_i \in \left\{ 0, 1\right\} \forall i = \overline{1,n}\right\}$.
\end{mydef}

\begin{mydef}
\emph{Булевой функцией} от переменных $x_1, ..., x_n$ будем называть отображение $f: {\mathbb{B}}^n \to {\mathbb{B}}^1$.
\end{mydef}

\begin{mydef}
Схемой из функциональных элементов (СФЭ) будем называть ориентированный помеченный граф, обладающий следующими свойствами:
\begin{enumerate}
\item в нем существует непустое множество вершин, помеченных как входные вершины;
\item в нем существует непустое множество вершин, помеченных как выходные вершины;
\item множества входных и выходных вершин не пересекаются;
\item вершины, не входящие в множество входных вершин, помечены символом некоторой БФ.
\end{enumerate}
\end{mydef}

Каждая метка вершины из множества входных вершин имеет смысл булевой переменной.
Пусть теперь символы, которыми могут быть помечены вершины, могут соответствовать только следующим БФ : NOT, AND, OR, XOR, NAND, NOR, XNOR.

\begin{mydef}
Булеву функцию, реализуемую в вершине СФЭ определим по индукции:
\begin{enumerate}
\item если вершина входит во множество входных вершин и помечена как $x_i$, то БФ, реализуемая в этой вершине есть: $f = x_i$;
\item если вершина не является входом и помечена символом некоторой БФ $F(p_1, ..., p_k)$, то в данной вершине реализуется БФ: $f = F(f_{i_1}, ..., f_{i_k})$, где $f_{i_1}, ..., f_{i_k}$ есть функции, реализуемые в вершинах, из которых исходят входящие в данную вершину ребра;
\end{enumerate}
\end{mydef}

\begin{mydef}
Частично заданной СФЭ (замаскированной СФЭ) $\Sigma$ будем называть такую схему $\Sigma^{'}$, которая получается путем удаления одного или нескольких ребер из исходной схемы $\Sigma$.
\end{mydef}

\begin{mydef}
Одновыходной СФЭ будем называть такую СФЭ, у которой множество выходных вершин содержит всего одну вершину графа.
\end{mydef}

Далее будем рассматривать только одновыходные схемы, т. е. схемы с единственной выходной вершиной.

\begin{mydef}
Классом БФ будем называть подмножество множества всех БФ, удовлетворяющих некоторому условию.
\end{mydef}

Определим несколько классов.

\begin{mydef}
$T_1 = \cup_{n = 1}^{\infty} \lbrace f\left(x_1, ..., x_n\right) \in P_2^n \vert f(1, ..., 1) = 1 \rbrace$.
\end{mydef}

\begin{mydef}
$T_0 = \cup_{n = 1}^{\infty} \lbrace f\left(x_1, ..., x_n\right) \in P_2^n \vert f(0, ..., 0) = 0 \rbrace$.
\end{mydef}

\begin{mydef}
Пусть $\overline{\alpha} = (\alpha_1, ..., \alpha_n)$ и $\overline{\beta} = (\beta_1, ..., \beta_n)$, тогда:
$\overline{\alpha} \leq (\geq) \overline{\beta} \Leftrightarrow \forall i \in \lbrace 1, ..., n\rbrace: \alpha_i \leq (\geq) \beta_i$.
\end{mydef}

\begin{mydef}
$M = \cup_{n = 1}^{\infty} \lbrace f\left(x_1, ..., x_n\right) \in P_2^n \  \vert \  \forall \overline{\alpha} \leq \overline{\beta}: f\left(\overline{\alpha}\right) \leq f\left(\overline{\beta}\right) \rbrace$.
\end{mydef}

Определим понятие вхождения СФЭ в класс. 

\begin{mydef}
Одновыходная СФЭ $\Sigma$ входит в класс $G \in P_2$ тогда и только тогда, когда в этот класс входит функция, реализуемая на выходе СФЭ.
\end{mydef}

\begin{mydef}
Восстановлением по частично заданной одновыходной СФЭ $\Sigma$ над множеством классов $\Gamma$ будем называть определение вхождения частично заданной одновыходной СФЭ $\Sigma$ в каждый из классов множества $\Gamma$. При этом оценкой качества восстановления над множеством $\Gamma$ будем называть долю классов, таких что исходная одновыходная СФЭ $\Sigma$ входит (не входит), а частично заданная одновыходная СФЭ $\Sigma$ не входит (входит), т. е. количество различий между вхождениями СФЭ.
\end{mydef}

Очевидно, чем ниже оценка, тем лучше восстановление.

\newpage
\section{\textbf{Постановка задачи}}
\noindent
\begin{enumerate}

\item Реализовать и протестировать способ представления СФЭ на ЭВМ;
\item Выделить набор признаков СФЭ, которые будут использоваться для машинного обучения;
\item Реализовать и протестировать алгоритмы вычисления признаков схемы; 
\item Реализовать алгоритм построения случайных СФЭ.
\end{enumerate}

\newpage
\section{Основная часть}

\subsection{\textbf{Реализация и тестирование способа представления СФЭ на ЭВМ}}
\noindent

Имеется класс Vertex и унаследованный от него класс Gate. Vertex предназначен для хранения входных вершин. Gate хранит данные о вершинах, не являющихся входными. Vertex - имеет поля имени, выходной степени и глубины. Унаследованный от него Gate ещё имеет поле для хранения входных ребер и типа(OR,XOR и т. д.).

Реализован класс Parser, который позволяет получать значащие лексемы из файла-описания СФЭ.

СФЭ реализована на ЭВМ как отдельный класс SFE с контейнером указателей на входные вершины(inputs), контейнером указателей на выходные вершины(ouputs) и контейнером указателей на вершины, которые не являются ни входными, ни выходными(gates). Схема задается в файле на языке Verilog. Также реализован ряд методов для работы с данным классом.

Данный набор классов реализован и полность протестирован на разлиных схемах.
\newpage

\subsection{\textbf{Выделение набора признаков СФЭ, которые будут использоваться для машинного обучения}}
\noindent

Были выделены следующие признаки:
\begin{enumerate}
\item процент каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR};
\item максимальная входная/выходная степень;
\item минимальная входная/выходная степень;
\item средняя входная/выходная степень;
\item средняя глубина, нормированная на максимальную глубину;
\item среднее количество значащих переменных, нормированное на общее количество переменных;
\end{enumerate}

Как рассчитывать первые три пункта - очевидно. Приведем рассчетные формулы для остальных пунктов. Введем ряд обозначений:
\begin{enumerate}
\item $d^{+}\left(v\right)$ - входная степень вершины $v$, равна количеству входных ребер;
\item $d^{-}\left(v\right)$ - выходная степень вершины $v$, равна количеству выходных ребер;
\item $I$ - множество всех входных вершин СФЭ;
\item $O$ - множество всех выходных вершин СФЭ;
\item $V$ - множество всех вершин СФЭ;
\item $D\left(v\right)$ - глубина вершины $v$;
\item $D\left(\Sigma\right)$ - глубина СФЭ $\Sigma$;
\item $CS\left(v\right)$ - значащие переменные вершины $v$;
\end{enumerate}\par
Расчет средней входной степени: $\frac{\sum\limits_{v \in V} d^{+}\left(v\right)}{|V|}$. Выходной аналогично.\par
Расчет средней глубины, нормированной на максимальную глубину: $\frac{\sum\limits_{v \in V} D\left(v\right)}{D\left(\Sigma\right)}$.\par
Вычисление среднего количества значащих переменных, нормированного на общее количество переменных: $\frac{\sum\limits_{v \in V \diagdown I} CS\left(v\right)}{|I|}$.

\newpage

\subsection{\textbf{Реализация и тестирование алгоритмов вычисления признаков схемы}}
\noindent

В классе SFE реализованы и протестированы следующие методы для рассчетов признаков СФЭ:
\begin{enumerate}
\item SFE::getPercentageTypeGate(typeGate t) - процент каждого возможного функционального элемента из множества {NOT, AND, OR, XOR, NAND, NOR, XNOR};
\item SFE::getMaxInputDegree() / SFE::getMaxOutputDegree() - максимальная входная/выходная степень;
\item SFE::getMinInputDegree() / SFE::getMinOutputDegree() - минимальная входная/выходная степень;
\item SFE::getMiddleInputDegree() / SFE::getMiddleInputDegree() - средняя входная/выходная степень;
\item SFE::getPercentageMiddleDepth() - средняя глубина, нормированная на максимальную глубину;
\item SFE::getPercentageMiddleSignVar() - среднее количество значащих переменных, нормированное на общее количество переменных.
\end{enumerate}

\newpage

\subsection{\textbf{Реализация алгоритма построения случайных СФЭ}}
\noindent
Для тестирования полученных алгоритмов, а также для генерации обучающих выборок СФЭ для машинного обучения, был реализован отдельный алгоритм, генерирующий случайную СФЭ, представленную в виде файла-описания на Verilog. Алгоритму нужно подать на вход максимальное количество входов, выходов и элементов, не являющихся ни входами, ни выходами, а также имя выходного файла. На основании этих данных алгоритм генерирует случайную СФЭ.

\newpage
\section{Полученные результаты}\par
Разработана реализация на языке С++ СФЭ на ЭВМ с возможность вычисления описанных выше признаков и считывания описания с файла-описания. Разработан генератор случайных СФЭ. 
\newpage
\section{Приложение}
\centerline{https://github.com/yura03101995/PracticeMSU.git}
По данной ссылке можно найти весь исходный код преддипломной практики.
\newpage


\begin{thebibliography}{30}

\bibitem{chipworks} Chipworks: 
\emph{"Intel‘s 22-nm Tri-gate Transistors Exposed"}, http://www.chipworks.com/blog/technologyblog/2012/04/23/intels-22-nm-tri-gate-transistors-exposed/, 2012

\bibitem{torrance} R. Torrance and D. James: 
\emph{"The state-of-the-art in semiconductor reverse engineering"}, IEEE/ACM Design Automation Conference, pp. 333–338, 2011

\bibitem{darpa} DARPA: 
\emph{"Integrity and Reliability of Integrated Circuits (IRIS)"}, http://www.darpa.mil/Our{\_}Work/MTO/Programs/
Integrity{\_}and{\_}Reliability{\_}of{\_}Integrated{\_}Circuits{\_}(IRIS).aspx, 2012

\bibitem{Jv} Jeyavijayan (Jv) Rajendran, Ozgur Sinanoglu, and Ramesh Karri: 
\emph{"Is split manufacturing secure?. In Proceedings of the Conference on Design, Automation and Test in Europe (DATE '13)"}, EDA Consortium, San Jose, CA, USA, 1259-1264, 2013

\bibitem{imeson} Frank Imeson, Ariq Emtenan, Siddharth Garg, and Mahesh V. Tripunitara:
\emph{"Securing computer hardware using 3D integrated circuit (IC) technology and split manufacturing for obfuscation. In Proceedings of the 22nd USENIX conference on Security (SEC'13)."}, USENIX Association, Berkeley, CA, USA, 495-510, 2013

\bibitem{jarvis} R.W Jarvis and M. G. McIntyre: 
\emph{"Split manufacturing method for advanced semiconductor circuits."}, US Patent no. 7195931, 2004


\end{thebibliography}


\end{document}

